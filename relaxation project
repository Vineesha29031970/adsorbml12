
Adsorption energy calculations using a toy calculator
A structural relaxation or structure optimization is the process of iteratively updating atom positions to find the atom positions that minimize the energy of the structure. Standard optimization methods are used in structural relaxations — below we use the Limited-Memory Broyden–Fletcher–Goldfarb–Shanno (LBFGS) algorithm. The step number, time, energy, and force max are printed at each optimization step. Each step is considered one example because it provides all the information we need to train models for the S2EF task and the entire set of steps is referred to as a trajectory. Visualizing intermediate structures or viewing the entire trajectory can be illuminating to understand what is physically happening and to look for problems in the simulation, especially when we run ML-driven relaxations.

{tip}
Common problems one may look out for:
* atoms excessively overlapping/colliding with each other
* atoms flying off into random directions
* the adsorbate molecule dissociating
* the adsorbate desorbing from the surface
* large changes to the surface indicating the surface is relaxed 
Setup and relaxation of a bare slab
First, let's set up a bare Cu(100) surface. We'll use ASE to make the initial structure, and LBFGS to do a quick relaxation to find the lowest energy configuration.

We'll fix the bottom couple layers of the copper surface to approximate a very thick copper slab and prevent the surface from moving. This is a very common trick in the catalysis community.

For this demonstration, we'll use the Effective Medium Theory (EMT) calculator from ASE. It works pretty well for simple metal structures like Cu(100) and is very fast. However, it won't do a good job with the adsorbate later on in the example!

import os

import ase.io
import numpy as np
from ase import Atoms
from ase.build import fcc100
from ase.calculators.emt import EMT
from ase.constraints import FixAtoms
from ase.io import extxyz
from ase.io.trajectory import Trajectory
from ase.optimize import LBFGS

# This cell sets up and runs a structural relaxation
# of a Cu(100) surface. It uses ASE scripts to make the surface.
# The actual surfaces in OC20 were prepared slightly differently.
substrate=input('enter:')
adsorb=input('enter:')
# Make the bare slab using an ASE helper script
slab = fcc100(substrate, size=(3, 3, 3))

# Tag all slab atoms below surface as 0, surface as 1, adsorbate as 2
tags = np.zeros(len(slab))
tags[18:27] = 1
slab.set_tags(tags)

# Fixed atoms are prevented from moving during a structure relaxation.
# We fix all slab atoms beneath the surface.
cons = FixAtoms(indices=[atom.index for atom in slab if (atom.tag == 0)])
slab.set_constraint(cons)
slab.center(vacuum=13.0, axis=2)
slab.set_pbc(True)

# Set the toy calculator (EMT) so ASE knows how to get energies/forces
# at each step
slab.calc = EMT()

os.makedirs("data", exist_ok=True)

# Define structure optimizer - LBFGS. Run for 100 steps,
# or if the max force on all atoms (fmax) is below 0 ev/A.
# fmax is typically set to 0.01-0.05 eV/A,
# for this demo however we run for the full 100 steps.

dyn = LBFGS(slab, trajectory="data/"+substrate+"100.traj")
dyn.run(fmax=0.03, steps=100)

traj = ase.io.read("data/"+substrate+"100.traj", ":")

# convert traj format to extxyz format (used by OC20 dataset)
columns = ["symbols", "positions", "move_mask", "tags"]
with open("data/"+substrate+"100.extxyz", "w") as f:
    extxyz.write_xyz(f, traj, columns=columns)
       Step     Time          Energy          fmax
LBFGS:    0 00:25:47        6.358309        0.568649
LBFGS:    1 00:25:47        6.317681        0.542596
LBFGS:    2 00:25:47        6.033526        0.255067
LBFGS:    3 00:25:47        5.987619        0.056898
LBFGS:    4 00:25:47        5.984890        0.004258
c:\Users\Kirthi\AppData\Local\Programs\Python\Python311\Lib\site-packages\ase\io\extxyz.py:311: UserWarning: Skipping unhashable information adsorbate_info
  warnings.warn('Skipping unhashable information '
Reading a trajectory
identifier = substrate+"100.extxyz"

# the `index` argument corresponds to what frame of the trajectory to read in, specifiying ":" reads in the full trajectory.
traj = ase.io.read(f"data/{identifier}", index=":")
Viewing a trajectory
Below we visualize the initial, middle, and final steps in the structural relaxation trajectory from above. Copper atoms in the surface are colored orange. EMT does a good job here and gets a relaxed structure very quickly. It only takes a few steps, and if you look closely you can see just the top layer of Cu atoms move a bit.

{tip}
Visualizations can be used as a quick sanity check to ensure the initial system is set up correctly and there are no major issues with the simulation!
import matplotlib.pyplot as plt
from ase.visualize.plot import animate
from matplotlib import rc

anim = animate(traj, radii=0.8, rotation=("-75x, 45y, 10z"))

rc("animation", html="jshtml")
anim

Once Loop Reflect

Relaxation of a slab and adsorbate ("adslab")
Now that we know how to run a simple relaxation of a bare slab with ASE and a toy calculator, let's do the same thing with a methoxy (CH3O*) intermediate on the surface.

import os

import ase.io
import numpy as np
from ase import Atoms
from ase.build import add_adsorbate, fcc100, molecule
from ase.calculators.emt import EMT
from ase.constraints import FixAtoms
from ase.io import extxyz
from ase.io.trajectory import Trajectory
from ase.optimize import LBFGS

# This cell sets up and runs a structural relaxation
# of a Cu(100) surface. It uses ASE scripts to make the surface.
# The actual surfaces in OC20 were prepared slightly differently.

# Make the bare slab using an ASE helper script
adslab = fcc100(substrate, size=(3, 3, 3))

# Now, let's add the adsorbate to the bare slab
adsorbate = molecule(adsorb)
add_adsorbate(adslab, adsorbate, 3, offset=(1, 1))  # adslab = adsorbate + slab

# Tag all slab atoms below surface as 0, surface as 1, adsorbate as 2
tags = np.zeros(len(adslab))
tags[18:27] = 1
tags[27:] = 2
adslab.set_tags(tags)

# Fixed atoms are prevented from moving during a structure relaxation.
# We fix all slab atoms beneath the surface.
cons = FixAtoms(indices=[atom.index for atom in adslab if (atom.tag == 0)])
adslab.set_constraint(cons)
adslab.center(vacuum=13.0, axis=2)
adslab.set_pbc(True)

# Set the toy calculator (EMT) so ASE knows how to get energies/forces
# at each step
adslab.calc = EMT()

os.makedirs("data", exist_ok=True)

# Define structure optimizer - LBFGS. Run for 100 steps,
# or if the max force on all atoms (fmax) is below 0 ev/A.
# fmax is typically set to 0.01-0.05 eV/A,
# for this demo however we run for the full 100 steps.

dyn = LBFGS(adslab, trajectory="data/"+substrate+"100+"+adsorb+".traj")
dyn.run(fmax=0.03, steps=100)

adslab_traj = ase.io.read("data/"+substrate+"100+"+adsorb+".traj", ":")

# convert traj format to extxyz format (used by OC20 dataset)
columns = ["symbols", "positions", "move_mask", "tags"]
with open("data/"+substrate+"100+"+adsorb+".extxyz", "w") as f:
    extxyz.write_xyz(f, adslab_traj, columns=columns)
       Step     Time          Energy          fmax
LBFGS:    0 00:26:00        9.244526        7.518960
LBFGS:    1 00:26:00        7.899526        4.799034
LBFGS:    2 00:26:00        7.311017        3.521549
LBFGS:    3 00:26:00        7.161006        0.519363
LBFGS:    4 00:26:00        7.116622        0.439121
LBFGS:    5 00:26:00        7.012318        0.551085
LBFGS:    6 00:26:00        6.991741        0.631053
LBFGS:    7 00:26:00        6.962054        0.541794
LBFGS:    8 00:26:00        6.945835        0.263738
LBFGS:    9 00:26:00        6.940840        0.105561
LBFGS:   10 00:26:00        6.940325        0.065768
LBFGS:   11 00:26:00        6.939791        0.053554
LBFGS:   12 00:26:00        6.939158        0.084522
LBFGS:   13 00:26:00        6.938150        0.114613
LBFGS:   14 00:26:00        6.937060        0.122764
LBFGS:   15 00:26:00        6.936187        0.095089
LBFGS:   16 00:26:00        6.935604        0.054507
LBFGS:   17 00:26:00        6.935029        0.094370
LBFGS:   18 00:26:00        6.934110        0.160096
LBFGS:   19 00:26:00        6.932174        0.235814
LBFGS:   20 00:26:00        6.928018        0.318876
LBFGS:   21 00:26:00        6.919887        0.412436
LBFGS:   22 00:26:00        6.905264        0.434975
LBFGS:   23 00:26:01        6.885899        0.740979
LBFGS:   24 00:26:01        6.881866        1.246986
LBFGS:   25 00:26:01        6.854868        0.712408
LBFGS:   26 00:26:01        6.834851        0.709834
LBFGS:   27 00:26:01        6.810889        1.038233
LBFGS:   28 00:26:01        6.774438        0.626892
LBFGS:   29 00:26:01        6.727709        0.548123
LBFGS:   30 00:26:01        6.651746        0.880608
LBFGS:   31 00:26:01        6.611336        0.466143
LBFGS:   32 00:26:01        6.578097        0.641739
LBFGS:   33 00:26:01        6.533486        0.727631
LBFGS:   34 00:26:01        6.516447        0.574422
LBFGS:   35 00:26:01        6.505540        0.722042
LBFGS:   36 00:26:01        6.491775        0.443186
LBFGS:   37 00:26:01        6.476954        0.228445
LBFGS:   38 00:26:01        6.472761        0.239247
LBFGS:   39 00:26:01        6.465315        0.370683
LBFGS:   40 00:26:01        6.455279        0.392411
LBFGS:   41 00:26:01        6.440346        0.323697
LBFGS:   42 00:26:01        6.427896        0.262545
LBFGS:   43 00:26:01        6.420262        0.194964
LBFGS:   44 00:26:01        6.413638        0.229949
LBFGS:   45 00:26:01        6.403181        0.315926
LBFGS:   46 00:26:01        6.390369        0.373441
LBFGS:   47 00:26:01        6.379583        0.348092
LBFGS:   48 00:26:01        6.368442        0.226940
LBFGS:   49 00:26:01        6.363006        0.192786
LBFGS:   50 00:26:01        6.358346        0.157231
LBFGS:   51 00:26:01        6.350299        0.176633
LBFGS:   52 00:26:01        6.338460        0.227125
LBFGS:   53 00:26:01        6.326606        0.291406
LBFGS:   54 00:26:01        6.297520        0.244424
LBFGS:   55 00:26:01        6.287729        0.599822
LBFGS:   56 00:26:01        6.270316        0.291502
LBFGS:   57 00:26:01        6.263578        0.242459
LBFGS:   58 00:26:01        6.251899        0.219804
LBFGS:   59 00:26:01        6.244277        0.180832
LBFGS:   60 00:26:01        6.236768        0.176343
LBFGS:   61 00:26:01        6.227048        0.213046
LBFGS:   62 00:26:01        6.220490        0.153790
LBFGS:   63 00:26:01        6.216221        0.157720
LBFGS:   64 00:26:01        6.213835        0.152200
LBFGS:   65 00:26:01        6.210872        0.139269
LBFGS:   66 00:26:01        6.206910        0.142344
LBFGS:   67 00:26:01        6.202897        0.110973
LBFGS:   68 00:26:01        6.199863        0.144875
LBFGS:   69 00:26:01        6.197919        0.147676
LBFGS:   70 00:26:01        6.195740        0.125073
LBFGS:   71 00:26:01        6.192501        0.208385
LBFGS:   72 00:26:01        6.187479        0.290908
LBFGS:   73 00:26:01        6.182329        0.265238
LBFGS:   74 00:26:01        6.178086        0.172940
LBFGS:   75 00:26:01        6.174233        0.146246
LBFGS:   76 00:26:01        6.169012        0.173458
LBFGS:   77 00:26:01        6.165434        0.467993
LBFGS:   78 00:26:01        6.153524        0.379579
LBFGS:   79 00:26:01        6.147830        0.263311
LBFGS:   80 00:26:01        6.138313        0.371716
LBFGS:   81 00:26:01        6.131322        0.215009
LBFGS:   82 00:26:01        6.122704        0.179972
LBFGS:   83 00:26:01        6.116600        0.153946
LBFGS:   84 00:26:01        6.113017        0.157655
LBFGS:   85 00:26:01        6.105605        0.156843
LBFGS:   86 00:26:01        6.099200        0.163361
LBFGS:   87 00:26:01        6.092255        0.138065
LBFGS:   88 00:26:01        6.087927        0.111392
LBFGS:   89 00:26:01        6.084683        0.133671
LBFGS:   90 00:26:01        6.080671        0.151852
LBFGS:   91 00:26:01        6.075019        0.175401
LBFGS:   92 00:26:01        6.069147        0.131814
LBFGS:   93 00:26:02        6.064175        0.132401
LBFGS:   94 00:26:02        6.061786        0.106469
LBFGS:   95 00:26:02        6.060447        0.081445
LBFGS:   96 00:26:02        6.058751        0.075123
LBFGS:   97 00:26:02        6.056467        0.081823
LBFGS:   98 00:26:02        6.054303        0.067922
LBFGS:   99 00:26:02        6.053018        0.060622
LBFGS:  100 00:26:02        6.052415        0.047965
c:\Users\Kirthi\AppData\Local\Programs\Python\Python311\Lib\site-packages\ase\io\extxyz.py:311: UserWarning: Skipping unhashable information adsorbate_info
  warnings.warn('Skipping unhashable information '
Note that this relaxation isn't quite finished - we stopped the relaxation at 100 steps but the force is still a bit higher than we wanted. Probably it would have converged if we had waited just a little longer.

Let's visualize the relaxation with the output and see what happens!

import matplotlib.pyplot as plt
from ase.visualize.plot import animate
from matplotlib import rc

anim = animate(adslab_traj, radii=0.8, rotation=("-75x, 45y, 10z"))

rc("animation", html="jshtml")
anim

Once Loop Reflect

Viewing a trajectory
Below we visualize the initial, middle, and final steps in the structural relaxation trajectory from above. Copper atoms in the surface are colored orange, the propane adsorbate on the surface has grey colored carbon atoms and white colored hydrogen atoms. The adsorbate’s structure changes during the simulation and you can see how it relaxes on the surface. In this case, the relaxation looks normal; however, there can be instances where the adsorbate flies away (desorbs) from the surface or the adsorbate can break apart (dissociation), which are hard to detect without visualization.

{tip}
Visualizations can be used as a quick sanity check to ensure the initial system is set up correctly and there are no major issues with the simulation!
import matplotlib.pyplot as plt
from ase.visualize.plot import animate
from matplotlib import rc

anim = animate(adslab_traj, radii=0.8, rotation=("-75x, 45y, 10z"))

rc("animation", html="jshtml")
anim

Once Loop Reflect

{warning}
Notice that this relaxation looks quite strange
* The oxygen is the most reactive atom here; the carbon atom is happy with four bonds (3 to H atoms, 1 to an O), but the O is clearly missing a bond. Without actually running a calculation, we could probably guess that a better configuration would be O pointing towards the copper surface. This shows that how we place the adsorbate here could be improved!
* The methoxy intermediate settles down onto the surface and falls apart (**dissociates**). The final structure is not the energy of a *OCH3 intermediate on a copper surface, but instead the energy of a collection of fragments. 

The poor relaxation is because we're using the EMT calculator, which works ok for some simple metal surfaces but is basically just a toy model for any organic atoms (C, H, O, etc). It's not a surprise that it fails for this calculation.
ASE trajectory and atoms object contents
Here we take a closer look at what information is contained within these trajectories.

i_structure = adslab_traj[0]
i_structure
Atoms(symbols='Au27COH3', pbc=True, cell=[8.654987001723343, 8.654987001723343, 33.983279], initial_magmoms=..., tags=..., constraint=FixAtoms(indices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]), calculator=SinglePointCalculator(...))
Atomic numbers
numbers = i_structure.get_atomic_numbers()
print(numbers)
[79 79 79 79 79 79 79 79 79 79 79 79 79 79 79 79 79 79 79 79 79 79 79 79
 79 79 79  6  8  1  1  1]
Atomic symbols
symbols = np.array(i_structure.get_chemical_symbols())
print(symbols)
['Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au'
 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'Au' 'C' 'O'
 'H' 'H' 'H']
Unit cell
The unit cell is the volume containing our system of interest. Express as a 3x3 array representing the directional vectors that make up the volume. Illustrated as the dashed box in the above visuals.

cell = np.array(i_structure.cell)
print(cell)
[[ 8.654987  0.        0.      ]
 [ 0.        8.654987  0.      ]
 [ 0.        0.       33.983279]]
Periodic boundary conditions (PBC)
x,y,z boolean representing whether a unit cell repeats in the corresponding directions. The OC20 dataset sets this to [True, True, True], with a large enough vacuum layer above the surface such that a unit cell does not see itself in the z direction. This is necessary since the underlying DFT calculation also requires periodic boundary conditions. However, not all DFT codes do!

Although the original structure shown above is what gets passed into our models, the presence of PBC allows it to effectively repeat infinitely in the x and y directions. Below we visualize the same structure with a periodicity of 2 in all directions, what the model may effectively see.

pbc = i_structure.pbc
print(pbc)
[ True  True  True]
fig, ax = plt.subplots(1, 3)
labels = ["initial", "middle", "final"]
for i in range(3):
    ax[i].axis("off")
    ax[i].set_title(labels[i])

ase.visualize.plot.plot_atoms(
    adslab_traj[0].repeat((2, 2, 1)), ax[0], radii=0.8, rotation=("-75x, 45y, 10z")
)
ase.visualize.plot.plot_atoms(
    adslab_traj[50].repeat((2, 2, 1)), ax[1], radii=0.8, rotation=("-75x, 45y, 10z")
)
ase.visualize.plot.plot_atoms(
    adslab_traj[-1].repeat((2, 2, 1)), ax[2], radii=0.8, rotation=("-75x, 45y, 10z")
)
<Axes: title={'center': 'final'}>

tags = i_structure.get_tags()
print(tags)
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 2 2 2 2 2]
Fixed atoms constraint
In reality, surfaces contain many, many more atoms beneath what we've illustrated as the surface. At an infinite depth, these subsurface atoms would look just like the bulk structure. We approximate a true surface by fixing the subsurface atoms into their “bulk” locations. This ensures that they cannot move at the “bottom” of the surface. If they could, this would throw off our calculations. Consistent with the above, we fix all atoms with tags=0, and denote them as "fixed". All other atoms are considered "free".

cons = i_structure.constraints[0]
print(cons, "\n")

# indices of fixed atoms
indices = cons.index
print(indices, "\n")

# fixed atoms correspond to tags = 0
print(tags[indices])
FixAtoms(indices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) 

[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17] 

[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
Force
Forces are another important property of the OC20 dataset. Unlike datasets like QM9 which contain only ground state properties, the OC20 dataset contains per-atom forces necessary to carry out atomistic simulations. Physically, forces are the negative gradient of energy w.r.t atomic positions: 
 
. Although not mandatory (depending on the application), maintaining this energy-force consistency is important for models that seek to make predictions on both properties.

The "apply_constraint" argument controls whether to apply system constraints to the forces. In the OC20 dataset, this controls whether to return forces for fixed atoms (apply_constraint=False) or return 0s (apply_constraint=True).

# Returning forces for all atoms - regardless of whether "fixed" or "free"
i_structure.get_forces(apply_constraint=False)
array([[-9.35837927e-08, -9.29543121e-08,  5.68648913e-01],
       [ 1.39227079e-09, -1.95288379e-06,  5.68643587e-01],
       [ 9.21915222e-08, -9.03970237e-08,  5.68648917e-01],
       [-2.86783524e-06, -4.60861642e-07,  5.68643051e-01],
       [ 2.90766318e-09, -1.37366822e-06,  5.68571712e-01],
       [ 2.86492757e-06, -4.61903539e-07,  5.68643089e-01],
       [-1.00534848e-06,  5.53815955e-07,  5.68647051e-01],
       [ 3.50376348e-10,  3.32655201e-06,  5.68627645e-01],
       [ 1.00499810e-06,  5.52300561e-07,  5.68647053e-01],
       [-2.18223706e-03, -2.23220876e-03, -4.79381409e-03],
       [ 1.99101215e-03, -1.82590052e-03, -3.15773791e-03],
       [-8.53451084e-07, -8.29634162e-05, -1.26946363e-04],
       [-1.96882716e-03,  1.68671034e-03, -3.13885728e-03],
       [ 1.90534362e-03,  1.41260285e-03, -2.53524449e-03],
       [-8.21482162e-07,  5.84663714e-05, -1.61477605e-04],
       [-3.83600984e-04,  3.48818902e-04, -5.86082305e-04],
       [ 3.83614734e-04,  3.48844060e-04, -5.86049887e-04],
       [-1.60780971e-08,  2.44927905e-05, -4.43659222e-05],
       [-4.71028928e-03, -4.77116741e-03, -5.72565477e-01],
       [ 1.40766563e-02, -7.84331957e-02, -6.31752476e-01],
       [ 9.61715488e-04, -8.82979611e-04, -5.69402695e-01],
       [-8.32414829e-02,  1.69903937e-02, -6.36234683e-01],
       [ 7.37102099e-01,  7.51742745e-01, -3.76946237e+00],
       [ 1.27566096e-02,  4.28926648e-03, -5.80060150e-01],
       [ 2.27858274e-03, -1.00764811e-03, -5.65295011e-01],
       [ 1.22060316e-03, -4.65787449e-02, -4.57322478e-01],
       [-2.73014844e-03, -1.64453980e-03, -5.64935361e-01],
       [ 8.54946046e-01,  7.03625229e+00,  2.50898118e+00],
       [ 4.50911782e-03, -2.84491933e+00, -1.92302998e-01],
       [ 2.69273979e+00, -7.89855821e-01,  7.77081338e-02],
       [-1.06307847e+00, -1.01651542e+00,  2.10941861e+00],
       [-3.16657445e+00, -3.02440470e+00, -1.25936466e+00]])
# Applying the fixed atoms constraint to the forces
i_structure.get_forces(apply_constraint=True)
array([[ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [-4.71028928e-03, -4.77116741e-03, -5.72565477e-01],
       [ 1.40766563e-02, -7.84331957e-02, -6.31752476e-01],
       [ 9.61715488e-04, -8.82979611e-04, -5.69402695e-01],
       [-8.32414829e-02,  1.69903937e-02, -6.36234683e-01],
       [ 7.37102099e-01,  7.51742745e-01, -3.76946237e+00],
       [ 1.27566096e-02,  4.28926648e-03, -5.80060150e-01],
       [ 2.27858274e-03, -1.00764811e-03, -5.65295011e-01],
       [ 1.22060316e-03, -4.65787449e-02, -4.57322478e-01],
       [-2.73014844e-03, -1.64453980e-03, -5.64935361e-01],
       [ 8.54946046e-01,  7.03625229e+00,  2.50898118e+00],
       [ 4.50911782e-03, -2.84491933e+00, -1.92302998e-01],
       [ 2.69273979e+00, -7.89855821e-01,  7.77081338e-02],
       [-1.06307847e+00, -1.01651542e+00,  2.10941861e+00],
       [-3.16657445e+00, -3.02440470e+00, -1.25936466e+00]])
Adsorption (reaction) energy referenced to gas phase species
The energy of the system is one of the properties of interest in the OC20 dataset. It's important to note that absolute energies provide little value to researchers and must be referenced properly to be useful. Put another way, all physically-meaningful energies in DFT are reaction energies from one state to another.

A common approach in catalysis to maintain consistency in energies is to reference all energies to a linear combination of specific gas phase species. For OC20, these species were N2, H2, H2O, and CO. These were chosen as the DFT method we're using does a reasonable job of calculating the energies of these species. In effect, we are calculating the energy of a specific reaction:
 
where 
 represents a catalyst surface site, and 
 represents our intermediate bound to the catalyst surface. All chemical reactions must balance, so with a little bit of linear algebra we can figure out what numbers 
 are:
 
 
This is the energy that would be reported or predicted for an OCH3 adsorbate in OC20. Another way that we could accomplish the same thing is to calculate a per-element energy for C,H,O,N from the reference energies: \begin{align} E_H = E_{\text{H2}}/2 && E_N = E_{\text{N2}}/2 && E_O = E_{\text{H2O}}-E_{H2} && E_C = E_{\text{CO}}-E_{\text{H2O}}+E_{H2} \end{align*} It is straightforward to convert from one reference energy scheme to another (e.g. a different set of gas-phase species), so the OC20 results are useful even if you are using a different approach!

{danger}
It is extremely important to use consistent settings for all steps in your adsorption energy calculation. If you use different settings or codes for different species, you will get wrong numbers!
As a demonstration we'll do all of this using the EMT potential, but be aware that the results are going to be quite strange since EMT doesn't work for the gas phase molecules on their own!

# Adslab energy
relaxed_adslab = ase.io.read("data/"+substrate+"100+"+adsorb+".traj")
adslab_energy = relaxed_adslab.get_potential_energy()
print(f"Adsorbate+slab energy = {adslab_energy:.2f} eV")

# Corresponding raw slab used in original adslab (adsorbate+slab) system.
slab = fcc100(substrate, size=(3, 3, 3))
tags = np.zeros(len(slab))
tags[18:27] = 1
slab.set_tags(tags)
cons = FixAtoms(indices=[atom.index for atom in slab if (atom.tag == 0)])
slab.set_constraint(cons)
slab.center(vacuum=13.0, axis=2)
slab.set_calculator(EMT())
dyn = LBFGS(slab)
dyn.run(fmax=0.03, steps=100)
slab_energy = slab.get_potential_energy()
print(f"Bare slab energy = {slab_energy:.2f} eV")

# Energy for H2O
H2O_atoms = molecule("H2O")
H2O_atoms.set_pbc(True)
H2O_atoms.set_cell([20, 20, 20])
H2O_atoms.set_calculator(EMT())
dyn = LBFGS(H2O_atoms)
dyn.run(fmax=0.03, steps=100)
H2O_energy = H2O_atoms.get_potential_energy()
print(f"H2O energy = {H2O_energy:.2f} eV")

# Energy for N2
N2_atoms = molecule("N2")
N2_atoms.set_pbc(True)
N2_atoms.set_cell([20, 20, 20])
N2_atoms.set_calculator(EMT())
dyn = LBFGS(N2_atoms)
dyn.run(fmax=0.03, steps=100)
N2_energy = N2_atoms.get_potential_energy()
print(f"N2 energy = {N2_energy:.2f} eV")

# Energy for CO
CO_atoms = molecule("CO")
CO_atoms.set_pbc(True)
CO_atoms.set_cell([20, 20, 20])
CO_atoms.set_calculator(EMT())
dyn = LBFGS(CO_atoms)
dyn.run(fmax=0.03, steps=100)
CO_energy = CO_atoms.get_potential_energy()
print(f"CO energy = {CO_energy:.2f} eV")

# Energy for H2
H2_atoms = molecule("H2")
H2_atoms.set_pbc(True)
H2_atoms.set_cell([20, 20, 20])
H2_atoms.set_calculator(EMT())
dyn = LBFGS(H2_atoms)
dyn.run(fmax=0.03, steps=100)
H2_energy = H2_atoms.get_potential_energy()
print(f"H2 energy = {H2_energy:.2f} eV")

gas_reference_energies = {
    "H": H2_energy / 2,
    "N": N2_energy / 2,
    "O": H2O_energy - H2_energy,
    "C": CO_energy - (H2O_energy - H2_energy),
}

adsorbate = Atoms(adsorb).get_chemical_symbols()

adsorbate_reference_energy = 0
for ads in adsorbate:
    adsorbate_reference_energy += gas_reference_energies[ads]

print(f"Adsorbate reference energy = {adsorbate_reference_energy:.2f} eV\n")

adsorption_energy = adslab_energy - slab_energy - adsorbate_reference_energy
print(f"Adsorption energy: {adsorption_energy:.2f} eV")
Adsorbate+slab energy = 6.05 eV
       Step     Time          Energy          fmax
LBFGS:    0 00:31:14        6.358309        0.568649
LBFGS:    1 00:31:14        6.317681        0.542596
LBFGS:    2 00:31:14        6.033526        0.255067
LBFGS:    3 00:31:14        5.987619        0.056898
LBFGS:    4 00:31:14        5.984890        0.004258
Bare slab energy = 5.98 eV
       Step     Time          Energy          fmax
LBFGS:    0 00:31:14        2.619811        7.738365
LBFGS:    1 00:31:14        1.912906        1.345448
LBFGS:    2 00:31:14        1.882033        0.403474
LBFGS:    3 00:31:14        1.879275        0.031663
LBFGS:    4 00:31:14        1.879253        0.009649
H2O energy = 1.88 eV
       Step     Time          Energy          fmax
LBFGS:    0 00:31:14        0.548765        3.964835
LBFGS:    1 00:31:14        0.269415        0.702390
LBFGS:    2 00:31:14        0.263420        0.225843
LBFGS:    3 00:31:14        0.262778        0.008377
N2 energy = 0.26 eV
       Step     Time          Energy          fmax
LBFGS:    0 00:31:14        0.786209        2.304859
LBFGS:    1 00:31:14        0.681828        0.794475
LBFGS:    2 00:31:14        0.670839        0.182804
LBFGS:    3 00:31:14        0.670284        0.010521
CO energy = 0.67 eV
       Step     Time          Energy          fmax
LBFGS:    0 00:31:14        1.158863        4.461901
LBFGS:    1 00:31:14        1.331933        5.415824
LBFGS:    2 00:31:14        1.081151        1.322336
LBFGS:    3 00:31:14        1.072702        0.634684
LBFGS:    4 00:31:14        1.070550        0.040243
LBFGS:    5 00:31:14        1.070541        0.001118
H2 energy = 1.07 eV
Adsorbate reference energy = 2.28 eV

Adsorption energy: -2.21 eV
C:\Users\Kirthi\AppData\Local\Temp\ipykernel_3672\1246848799.py:14: DeprecationWarning: Please use atoms.calc = calc
  slab.set_calculator(EMT())
C:\Users\Kirthi\AppData\Local\Temp\ipykernel_3672\1246848799.py:24: DeprecationWarning: Please use atoms.calc = calc
  H2O_atoms.set_calculator(EMT())
C:\Users\Kirthi\AppData\Local\Temp\ipykernel_3672\1246848799.py:34: DeprecationWarning: Please use atoms.calc = calc
  N2_atoms.set_calculator(EMT())
C:\Users\Kirthi\AppData\Local\Temp\ipykernel_3672\1246848799.py:44: DeprecationWarning: Please use atoms.calc = calc
  CO_atoms.set_calculator(EMT())
C:\Users\Kirthi\AppData\Local\Temp\ipykernel_3672\1246848799.py:54: DeprecationWarning: Please use atoms.calc = calc
  H2_atoms.set_calculator(EMT())
{danger}
These gas-phase energies should not be trusted! Don't use them for anything more than this demo. Use a real calculation with consistent settings to your adslab to get the C/H/O/N energies!
Plot energy profile of toy trajectory
Plotting the energy profile of our trajectory is a good way to ensure nothing strange has occured. We expect to see a decreasing monotonic function. If the energy is consistently increasing or there's multiple large spikes this could be a sign of some issues in the optimization. This is particularly useful for when analyzing ML-driven relaxations and whether they make general physical sense.

import pandas as pd
import plotly.express as px

energies = [
    image.get_potential_energy() - slab_energy - adsorbate_reference_energy
    for image in adslab_traj
]

df = pd.DataFrame(
    {"Relaxation Step": range(len(energies)), "Adsorption Energy [eV]": energies}
)

fig = px.line(df, x="Relaxation Step", y="Adsorption Energy [eV]")
fig.show()
# Calculate summary statistics
mean_energy = df["Adsorption Energy [eV]"].mean()
median_energy = df["Adsorption Energy [eV]"].median()
min_energy = df["Adsorption Energy [eV]"].min()
max_energy = df["Adsorption Energy [eV]"].max()
std_dev_energy = df["Adsorption Energy [eV]"].std()

# Print the summary statistics
print(f"Mean Adsorption Energy: {mean_energy:.2f} eV")
print(f"Median Adsorption Energy: {median_energy:.2f} eV")
print(f"Min Adsorption Energy: {min_energy:.2f} eV")
print(f"Max Adsorption Energy: {max_energy:.2f} eV")
print(f"Standard Deviation: {std_dev_energy:.2f} eV")

# Calculate differences between consecutive steps
df["Change in Energy [eV]"] = df["Adsorption Energy [eV]"].diff()
print(df[["Relaxation Step", "Change in Energy [eV]"]])
Mean Adsorption Energy: -1.77 eV
Median Adsorption Energy: -1.90 eV
Min Adsorption Energy: -2.21 eV
Max Adsorption Energy: 0.98 eV
Standard Deviation: 0.46 eV
     Relaxation Step  Change in Energy [eV]
0                  0                    NaN
1                  1              -1.345000
2                  2              -0.588509
3                  3              -0.150012
4                  4              -0.044383
..               ...                    ...
96                96              -0.001696
97                97              -0.002284
98                98              -0.002164
99                99              -0.001285
100              100              -0.000603

[101 rows x 2 columns]
